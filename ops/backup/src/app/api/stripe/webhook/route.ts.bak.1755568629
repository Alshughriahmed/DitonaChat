import { NextRequest, NextResponse } from "next/server";
import { stripe } from "@/lib/stripe";
import { prisma } from "@/lib/db";

export const dynamic = "force-dynamic";

async function raw(req: NextRequest) {
  const b = await req.arrayBuffer();
  return Buffer.from(b);
}

export async function POST(req: NextRequest) {
  const sig = req.headers.get("stripe-signature") || "";
  const whsec = process.env.STRIPE_WEBHOOK_SECRET || "";
  const bypass = process.env.P2_STRIPE_BYPASS_DEV === "1" && process.env.NODE_ENV !== "production";

  let event: any;
  try {
    const buf = await raw(req);
    event = (whsec && !bypass)
      ? stripe.webhooks.constructEvent(buf, sig, whsec)
      : JSON.parse(buf.toString("utf8"));
  } catch (e: any) {
    return NextResponse.json({ ok:false, error:"BAD_SIGNATURE_OR_JSON", detail:String(e?.message||e) }, { status:400 });
  }

  const eid = String(event.id || "");
  // Dedup قبل المعالجة
  if (eid) {
    const existed = await prisma.processedWebhook.findUnique({ where: { eventId: eid } }).catch(()=>null);
    if (existed) return NextResponse.json({ ok:true, dedup:true });
  }

  let softFail: { reason?: string } | null = null;

  try {
    switch (event.type) {
      case "customer.subscription.created":
      case "customer.subscription.updated": {
        const sub = event.data.object;
        const stripeSubId = String(sub.id);
        const stripeCustomerId = String(sub.customer || "");
        const status = String(sub.status || "");
        const priceId = String(sub.items?.data?.[0]?.price?.id || "");
        const currentPeriodEnd = sub.current_period_end ? new Date(sub.current_period_end * 1000) : null;

        // ابحث عن اشتراك موجود بنفس stripeSubId
        const existing = await prisma.subscription.findFirst({ where: { stripeSubId } });

        try {
          if (existing) {
            await prisma.subscription.update({
              where: { id: existing.id },
              data: {
                status,
                stripeCustomerId,
                stripeSubId,
                currentPeriodEnd: currentPeriodEnd ?? existing.currentPeriodEnd,
                plan: priceId || existing.plan || "default",
              },
            });
          } else {
            // قد يفشل لو userId مطلوب في سكيمتك — نعالج ذلك بهدوء
            await prisma.subscription.create({
              data: {
                status,
                stripeCustomerId,
                stripeSubId,
                currentPeriodEnd: currentPeriodEnd ?? undefined,
                plan: priceId || "default",
              },
            });
          }
        } catch (err: any) {
          // أخطاء قيود DB (null/foreign key/unique ...) — لا نفشل الـwebhook في dev
          softFail = { reason: String(err?.code || err?.message || err) };
          console.error("[stripe][webhook] soft-fail:", softFail.reason);
        }
        break;
      }
      case "customer.subscription.deleted": {
        const sub = event.data.object;
        const stripeSubId = String(sub.id);
        const existing = await prisma.subscription.findFirst({ where: { stripeSubId } });
        if (existing) {
          try {
            await prisma.subscription.update({ where: { id: existing.id }, data: { status: "canceled" } });
          } catch (err: any) {
            softFail = { reason: String(err?.code || err?.message || err) };
            console.error("[stripe][webhook] soft-fail(delete):", softFail.reason);
          }
        }
        break;
      }
      default:
        break;
    }
  } catch (err: any) {
    console.error("[stripe][webhook] handler error:", err);
    // حتى في الأخطاء العامة، نسجّل الحدث ونعيد 200 في dev لتجنّب إعادة المحاولة اللانهائية
    try { if (eid) await prisma.processedWebhook.create({ data: { eventId: eid } }); } catch {}
    return NextResponse.json({ ok:true, softFail:true, reason:String(err?.message||err) });
  }

  try { if (eid) await prisma.processedWebhook.create({ data: { eventId: eid } }); } catch {}
  return NextResponse.json({ ok:true, ...(softFail ? { softFail:true, ...softFail } : {}) });
}
